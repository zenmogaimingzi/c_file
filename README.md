学习c语言；
基础语法：


cl 编译
link 链接文件

编译器 有1-4编译级别  1简单-4最难

```c
cl /c /W4 Hello.c
```


WinHex -观察器

引入依赖

```
#include <> 代表只找环境变量
#include ""	先找当前目录，再找环境变量 
```

代码规范

代码按照行规范；

#include 

 预处理命令生成 

```
cl /c /W4 /P  Hello.c
```

声明都在.h文件
具体处理逻辑放到.c文件

命令	行为

```
cl /c /W4 Hello.c	正常编译成 Hello.obj 文件，供后续链接使用。
cl /c /W4 /P Hello.c	只做预处理，生成 Hello.i 文件（文本文件），不会生成 .obj 文件。
```

#include <stdio.sh>


#include <stdio.h> // hpp .hxx 
// #include "test.c"

```
int main()
{
	int n =99;
	printf("Hello world !%p:%d\r\n",&n,n);

	//foo();
	getchar();
	return 0;

}
```


printf

```
printf 开销大
```



栈特点（类似于装子弹）

```
1、按调用约定传递参数。
1.1调用约定 调用方（caller）需要和被调方（callee）作出以下约定：
	1、参数的传递方向。
	2、参数的传输媒介。
	3、函数返回值的位置。
	4、释放参数空间的负责方，有且仅有以访去释放参数空间。
——cdecl:参数使用栈空间传递，从右往左，函数返回值在寄存器，由调用方负责释放参数空间；
——stdcall:参数使用栈空间传递，从右往左，函数返回值在寄存器，由调用方负责释放参数空间；
——fastcall:左数前两个参数使用寄存器传递，其他参数使用栈空间传递，从右往左，函数返回值在寄存器，由调用方负责释放参数空间；
2、保存返回地址。
3、保存调用方的栈信息（栈底）。
4、更新当前栈底到栈顶。（把当前栈顶作为被调用方的栈底）
5、为局部变量申请空间。（太高栈顶）
6、保存寄存器环境。（把即将使用的寄存器原值保存在栈里）
*7、如果编译选项有/ZI Zi, 则将局部变量初始化为0xcccccccc。
8、执行函数体。
9、恢复寄存器环境。
10、释放局部变量的空间。
11、恢复调用方的栈信息（栈底）。
12A、如果是——cdecl约定、取出当前栈顶作为返回的流程地址，返回到调用方后，由调用方清理参数空间。
12B、其他约定，取出当前栈顶作为返回的流程地址，同时由被调方清理参数空间后才返回。

```

